[TOC]

# 简介

本文件为微信小程序“Stop Buy, Get Desire!”的设计文档。

Stop Buy, Get Desire! 是一款与众不同的“剁手党”管理工具，结合游戏机制，促使用户更积极地使用曾因“我可能会用到”而花钱买入的物品，避免最终闲置浪费，同时以积分/等级/实际价格等对应方式，能直观感受到自己的剁手程度，遏制剁手的欲望——

若想要购入“喜欢而使用性差”的物品，就要掂量掂量从前花钱买入的等价位商品是否有投入使用？或许看一看曾经已经购买的“喜欢而使用性差”的物品的使用次数与频率，就会打消当前购买的欲望呢！

# 一、开发环境

形式：微信小程序

开发平台：微信开发者工具 stable 1.05.2103200

开发语言：后端 js；前端 wxml+wxss

实测设备：iphone 7

# 二、系统架构

小程序主要有以下几个界面：

- 小程序主界面（未登录）

- 主页/我的（登录）

  主页包括：1.任务列表；2.欲望商店

  "我的"包括：1.积分账单；2.使用说明；3.关于我们

系统总体架构图如下：

![image-20210421165933384](设计文档.assets/image-20210421165933384.png)

# 三、功能模块

该小程序主要有4个功能模块。功能模块与对应的代码模块为：

## 四个功能模块

1. `注册与登录`模块

   主要功能：用户登录与注册

2. `我的`模块

   主要功能：用户信息查看，积分/等级/历史操作记录 

3. 主页 

   1. `任务列表`模块

      主要功能：已剁手商品与使用情况记录

   2. `欲望商店`模块

      主要功能：期待剁手商品记录与管理 

## 主要操作

### 登录

1. 小程序运行后，首先通过云开发平台的云函数获取微信账户信息，点击开始征程后，效果如图：

   <img src="设计文档.assets/image-20210421173514344.png" alt="image-20210421173514344" style="zoom: 50%;" />  

2. 点击允许后，进入主页，包括任务列表、欲望商店两个主要模块，上方header显示用户头像、等级、积分与经验EXP，下发tab可切换主页与"我的"：

   <img src="设计文档.assets/image-20210421173651463.png" alt="image-20210421173651463" style="zoom: 33%;" />   

### "我的"

1. 点击下方tab，进入"我的"页面，显示用户当前等级，积分，及其他几个选项

   <img src="设计文档.assets/image-20210421181902287.png" alt="image-20210421181902287" style="zoom:33%;" /> 

2. 进入积分账单，点击上方"全部积分账单"，选择后点击确定，可分类查看

   <img src="设计文档.assets/image-20210421181955028.png" alt="image-20210421181955028" style="zoom:33%;" /> <img src="设计文档.assets/image-20210421182002463.png" alt="image-20210421182002463" style="zoom:33%;" /> <img src="设计文档.assets/image-20210421182009122.png" alt="image-20210421182009122" style="zoom:33%;" />

3. 进入 "使用方法"，滑动可查看基本操作介绍

   <img src="设计文档.assets/image-20210421182203579.png" alt="image-20210421182203579" style="zoom:33%;" /> <img src="设计文档.assets/image-20210421182209841.png" alt="image-20210421182209841" style="zoom:33%;" /> <img src="设计文档.assets/image-20210421182216664.png" alt="image-20210421182216664" style="zoom:33%;" /> 

4. 进入"关于我们"，查看小程序简介

   <img src="设计文档.assets/image-20210421182303274.png" alt="image-20210421182303274" style="zoom:33%;" /> 

### 任务列表

1. 通过主页-任务列表进入已剁手商品记录页面，上方tab切换商品类别

   <img src="设计文档.assets/image-20210421174215355.png" alt="image-20210421174215355" style="zoom:33%;" />  <img src="设计文档.assets/image-20210421174432391.png" alt="image-20210421174432391" style="zoom:33%;" /> 

2. 点击悬浮按钮"+"新增任务，其中，日用品无截止日期选项，见下图1"无"，其他类别可选择截止日期，见下最右图

    <img src="设计文档.assets/image-20210421174804762.png" alt="image-20210421174804762" style="zoom:33%;" />  <img src="设计文档.assets/image-20210421174814600.png" alt="image-20210421174814600" style="zoom:33%;" />  <img src="设计文档.assets/image-20210421175103836.png" alt="image-20210421175103836" style="zoom:33%;" />

3. 单击前方的选框，表示使用该商品一次，未达到设定的预期次数的商品选框中仅显示“选中”（蓝点）一段时间就恢复未选中状态，同时用户获得相应积分与经验可在上方header查看；达到使用次数的商品会被列入“已完成”

   如下“鼠标”使用次数已达标，4.中新增的任务只使用了1次：

   <img src="设计文档.assets/image-20210421175459668.png" alt="image-20210421175459668" style="zoom:33%;" /> 

6. 考虑到悬浮按钮可能遮挡部分商品右侧的积分与价格，按钮可上下移动：

   <img src="设计文档.assets/image-20210421175733877.png" alt="image-20210421175733877" style="zoom:33%;" /> <img src="设计文档.assets/image-20210421175459668.png" alt="image-20210421175459668" style="zoom:33%;" /> 

7. 右滑可删除任务，点击确定后删除

    <img src="设计文档.assets/image-20210421175914193.png" alt="image-20210421175914193" style="zoom:33%;" /> <img src="设计文档.assets/image-20210421175922572.png" alt="image-20210421175922572" style="zoom:33%;" /> <img src="设计文档.assets/image-20210421175929579.png" alt="image-20210421175929579" style="zoom:33%;" /> 

### 欲望商店

1. 通过主页-欲望商店进入期待购买的欲望商品页面

   <img src="设计文档.assets/image-20210421180157779.png" alt="image-20210421180157779" style="zoom:33%;" />  

2. 点击悬浮按钮"+"，可选择排序或添加

   排序：按商品价格升序排序：

   <img src="设计文档.assets/image-20210421180905369.png" alt="image-20210421180905369" style="zoom:33%;" /> <img src="设计文档.assets/image-20210421180913084.png" alt="image-20210421180913084" style="zoom:33%;" /> <img src="设计文档.assets/image-20210421180920503.png" alt="image-20210421180920503" style="zoom:33%;" /> 

   添加：新增欲望商品，点击保存后添加成功，设置了对"商品金额"输入内容的控制

   <img src="设计文档.assets/image-20210421180309769.png" alt="image-20210421180309769" style="zoom:33%;" /> <img src="设计文档.assets/image-20210421180327673.png" alt="image-20210421180327673" style="zoom:33%;" /> <img src="设计文档.assets/image-20210421180421938.png" alt="image-20210421180421938" style="zoom:33%;" /> 

3. 单击某商品，表示将使用对应积分购买该商品，积分不足时会有提示，购买成功后商品移除，并扣除响应积分

    <img src="设计文档.assets/image-20210421180645455.png" alt="image-20210421180645455" style="zoom:33%;" /> <img src="设计文档.assets/image-20210421180652634.png" alt="image-20210421180652634" style="zoom:33%;" /> <img src="设计文档.assets/image-20210421181128383.png" alt="image-20210421181128383" style="zoom:33%;" /> 

6. 考虑到悬浮按钮可能遮挡部分商品右侧的积分与价格，按钮可上下移动，同"任务列表"
7. 右滑可删除任务，点击确定后删除，同"任务列表"

# 四、程序总体结构

## 代码目录

使用 `tree` 命令生成程序`文件夹`结构如下：

```c
├─cloudfunctions
│  └─login //云开发登录
└─miniprogram
    └─pages
        ├─data
        ├─images //界面图标
        │  └─instruction //"使用方法"滑动图片文件夹
        ├─index //主页
        │  ├─buy //任务列表
        │  │  └─template
        │  ├─desirestore //欲望上电
        │  │  └─desirestore-item
        │  └─template
        ├─login //注册
        ├─me //"我的"
        │  ├─aboutus //关于我们
        │  ├─feature-template 
        │  ├─instruction //使用方法
        │  └─record //积分账单
        │      └─record-template
        └─util
```

## 入口文件说明

小程序执行入口文件为根目录下的app.js。

小程序启动，便首先执行该文件内容，即判断用户是否存在，实现用户数据的同步、或新建用户信息。

总入口执行完后，按照app.json 中定义的 pages 的顺序逐一执行.js文件：

```json
  "pages": [
    "pages/index/index",
    "pages/index/buy/buy",
    "pages/index/desirestore/desirestore",
    "pages/login/login",
    "pages/me/me",
    "pages/me/record/record",
    "pages/me/aboutus/aboutus",
    "pages/me/instruction/instruction"
  ],
```

首行即为小程序进入后首先显示的主页，其余行均为代码目录中的某项。

## 功能模块及对应文件

公有4个功能模块，功能模块对应的实现代码结构如下：

1. `注册与登录`模块

   使用云开发平台，实现微信账号和小程序的链接：

   <img src="设计文档.assets/image-20210421171506149.png" alt="image-20210421171506149" style="zoom:50%;" /> 

   新用户注册：

   <img src="设计文档.assets/image-20210421171623171.png" alt="image-20210421171623171" style="zoom:67%;" /> 

2. `我的`模块

   主要功能：用户信息查看，积分/等级/历史操作记录

   <img src="设计文档.assets/image-20210421171553261.png" alt="image-20210421171553261" style="zoom:67%;" /> 

3. 主页

   <img src="设计文档.assets/image-20210421172520581.png" alt="image-20210421172520581" style="zoom:67%;" /> 

   1. `任务列表`模块

      主要功能：已剁手商品与使用情况记录

      <img src="设计文档.assets/image-20210421172556332.png" alt="image-20210421172556332" style="zoom:67%;" /> 

   2. `欲望商店`模块

      主要功能：期待剁手商品记录与管理

      <img src="设计文档.assets/image-20210421172615664.png" alt="image-20210421172615664" style="zoom:67%;" /> 

# 五、数据结构设计

该小程序主要使用的数据结构为云开发提供的JSON数据库，数据库中的每条记录都是一个 JSON 格式的对象。一个数据库可以有多个集合（相当于关系型数据中的表），集合可看做一个 JSON 数组，数组中的每个对象就是一条记录，记录的格式是 JSON 对象。

设计如下：

## 创建

手动在云开发控制台创建数据集合

<img src="设计文档.assets/image-20210421184650319.png" alt="image-20210421184650319" style="zoom:50%;" /> 

## 初始化

小程序执行入口文件为根目录下的app.js，在app.js中，在每次使用小程序时初始化数据库内容

载入时在onLaunch()获取用户的openid

```js
onLaunch: function () {
    ...
    ...
    // 获取用户openid
    this.onGetOpenid()
  },
      
//onGetOpenid调用云函数，以同步登录用户信息
  onGetOpenid: function () {
    // 调用云函数
    wx.cloud.callFunction({
      name: 'login',
      data: {},
      success: res => {
        console.log('[云函数] [login] user openid: ', res.result.openid)
        this.globalData.openid = res.result.openid
        // 从云端获取用户信息，若没有则创建新用户
        this.onGetUserInfo()
      },
      fail: err => {
        console.error('[云函数] [login] 调用失败', err)
      }
    })
  },
```

首先查看该openid是否有对应用户存在（是否注册过）

```js
onGetUserInfo: function () {
    const db = wx.cloud.database()
    db.collection('userData').where({
      _openid: this.globalData.openid
    }).get({
      success: res => {
        if (res.data.length) {
            ......
        }
        else {
          ......
          })
        }
      }
    })
  },
```

若无，调用注册文件“../login/login”

```js
        else {
          console.log('[数据库] [查询记录] 成功 云端没有该用户信息，建立新用户')
          wx.navigateTo({
            url: '../login/login',
          })
        }
```

若有，用获取的openid从数据集中筛选该用户的数据，初始化小程序显示内容

```js
        if (res.data.length) {
          console.log('[数据库] [查询记录] 用户数据查询成功')
          wx.setStorageSync('userData', res.data[0])
          if (this.getUserDataCallback) {
            this.getUserDataCallback()
          }
          this.onQuery('taskData')
          this.onQuery('recordData')
        }
```

其中，`onQuery('taskData') `与 `onQuery('recordData')` 使用 `onQuery` 函数初始化当前用户的任务数据与积分账单历史数据，并进行任务ddl判断处理，同时将 `taskData` 数据表中内容使用 `wx.setStorageSync` 存入缓存，供其余.js文件使用。

```js
  onQuery: function (table) {
    const db = wx.cloud.database()
    // 查询当前用户的所有任务
    db.collection(table).where({
      _openid: this.globalData.openid
    }).get({
      success: res => {
        // 对taskData进行处理
        if (table === 'taskData') {
          var taskData = res.data
          taskData.forEach(item => {
            // 如果任务存在DDL，则判断是否过期
            if (item.due) {
              var ddl = new Date(item.due)
              var current = new Date(new Date().Format('yyyy-MM-dd'))
              if (!item.status.finished && ddl.getTime() - current.getTime() < 0) {
                item.status.expired = true
                item.expiredstr = `${ddl.getMonth() + 1}月${ddl.getDate()}日`
              }
              item.timestr = `${ddl.getMonth() + 1}月${ddl.getDate()}日`
            }
          })
        }
        if (table === 'taskData') {
          wx.setStorageSync('taskData', taskData)
        }
        else {
          wx.setStorageSync(table, res.data)
        }
      },
      fail: err => {
        console.error('[数据库] [查新记录] 失败', err)
      }
    })
  },
```

## 更新

### 运行时更新

运行中途**小部分数据**直接更新，在以下文件中：

<img src="设计文档.assets/image-20210421191350252.png" alt="image-20210421191350252" style="zoom: 67%;" /> 

1. buy.js：新增已剁手商品、删除时更新

   ```js
   //addtask(e)、deletetask(e)函数中
   		const db = wx.cloud.database()
           db.collection('taskData').add({//任务加入数据库
               data: newtask,
               success: res => {...
   ```

2. desirestore.js：新增期待剁手商品、删除时更新

   ```js
   //adddesire(e)、deletedesire(e)函数中
   		const db = wx.cloud.database()
           db.collection('desireData').add({
               data: newdata,
               success: res => {
   ```

3. login.js：注册新用户、为新用户初始化任务列表时更新

   ```js
   //注册
   bindGetUserInfo(e) {
       wx.getUserProfile({
         desc: '用于同步与完善个人资料', // 声明获取用户个人信息后的用途，后续会展示在弹窗中，请谨慎填写
         success: (res) => {
           app.globalData.userInfo = res.userInfo
           const db = wx.cloud.database()
           db.collection('userData').add({
             data: {
               level: 0,//初始0级
               money: 0,
               exp: 0,//初始0分
               username: app.globalData.userInfo.nickName
             },
             success: res => {...
                 
   //初始化任务列表
     initTask: function () {
       const db = wx.cloud.database()
       var initTasks = initTaskData.initTaskData
       initTasks.forEach(item => {
         db.collection('taskData').add({
           data: item,
           success: res => {...
   ```

   任务列表初始化内容存储在：

   └─miniprogram
       └─pages
           ├─data //内的initTaskData.js中

### 切出时提交云端

在小程序的单次运行过程中（不切出后台），**大部分**数据使用缓存，` wx.getStorageSync` 与 `wx.setStorage` 进行交互使用，若切出后台，才将所有数据在 `onHide` 函数中提交云端：

```js
  // 小程序被切到后台，提交数据到云端
  onHide: function () {
    const db = wx.cloud.database()
    
    // 更新userData
    var userData = wx.getStorageSync('userData')
    db.collection('userData').doc(userData._id).update({
      data: {
          exp: userData.exp,
          level: userData.level,
        money: userData.money
      },
      success: ...
      fail: ...
    })

    // 更新taskData
    var taskData = wx.getStorageSync('taskData')
    taskData.forEach(item => {
      if (item.today) {
        task.lastwork = new Date().Format('yyyy-MM-dd')
      }
      db.collection('taskData').doc(item._id).update({
        data: {
          checkcount: item.checkcount,
          status: item.status
        },
        success:...
        fail: ...
      })
    })

  
    // 上传recordData
    var recordData = wx.getStorageSync('recordData')
    recordData.forEach(item => {
      db.collection('recordData').where({
        _openid: this.globalData.openid,
        optid: item.optid
      }).get({
        success:...
              fail:...
            })
          }
        }
      })
    })
  }
})
```

# 六、界面主要设计

该小程序主要使用了wxml模板实现许多重复性的界面设计，从缓存 `wx.setStorageSync`中用 `wx.getStorageSync`取出数据，使用 `<view wx:for="{{...}}">` 循环，对每个项目使用模板，生成界面。

此外，class样式也在wxml模板的同级文件夹下，供模板调用时渲染。

## 模板导入

导入模板示例：

```html
<import src="../template/template.wxml" />
<import src="./desirestore-item/desirestore-item.wxml" />
```

## 用户信息header

> 界面

<img src="设计文档.assets/image-20210421200753563.png" alt="image-20210421200753563" style="zoom:50%;" /> 

> 模板位置

<img src="设计文档.assets/image-20210421195549284.png" alt="image-20210421195549284" style="zoom:67%;" /> 

> 使用位置

1. `主页`
2. `任务列表` 模块
3. `欲望商店 `模块

> 模板代码：`userInfoTemplate` 

```html
<template name="userInfoTemplate">
    <view class="user-info">
        <view class="user-avatar">
            <open-data type="userAvatarUrl"></open-data>
        </view>
        <view class="user-level-money">
            <text class="user-level">LV {{ user.level }}</text>
            <text class="user-money">￥ {{ user.money }}</text>
        </view>
        <text class="user-exp-text">EXP</text>
        <progress class="user-exp-progress" percent="{{percent}}" color="#0060AC" />
  </view>
</template>
```

## 任务列表的每一项

> 界面

 <img src="设计文档.assets/image-20210421201211276.png" alt="image-20210421201211276" style="zoom:67%;" /> 

> 模板位置

<img src="设计文档.assets/image-20210421195510629.png" alt="image-20210421195510629" style="zoom: 67%;" />  

> 使用位置

1. `任务列表` 模块

> 模板代码：`taskTemplate` 

```html
略
```

## 欲望商店列表的每一项

> 界面

 <img src="设计文档.assets/image-20210421201354544.png" alt="image-20210421201354544" style="zoom:67%;" /> 

> 模板位置

<img src="设计文档.assets/image-20210421195532595.png" alt="image-20210421195532595" style="zoom:67%;" />  

> 使用位置

1. `欲望商店` 模块

> 模板代码：`store-item` 

```
略
```

## 积分账单的每一项

> 界面

 <img src="设计文档.assets/image-20210421201505030.png" alt="image-20210421201505030" style="zoom:67%;" />  

> 模板位置

<img src="设计文档.assets/image-20210421195609435.png" alt="image-20210421195609435" style="zoom:67%;" />  

> 使用位置

1. `我的` 模块-积分账单

> 模板代码：`store-item` 

```html
<template name="featureItem">
    <view class="featureItem" catch:tap="changePage" data-pagename="{{ item }}">
        <text>{{item}}</text>
        <view class="rarrow">
        </view>
    </view>
</template>
```

#    七、主要功能实现

## 登录与注册

首先，我使用自己的微信号申请了云开发的使用权，在创建该项目时选中"开启云开发服务"。

从而在文件夹 ` cloud-functions/login` 中，我可以利用小程序·云开发提供的多个基础能力，将经自动鉴权过的小程序用户 openid 返回给小程序端，获取 WX Context (微信调用上下文)，包括 OPENID、APPID、及 UNIONID（需满足 UNIONID 获取条件），实现对小程序使用者身份的识别：

```js
//cloud-functions/login/index.js
const cloud = require('wx-server-sdk')

// 初始化 cloud
cloud.init()

exports.main = async (event, context) => {
  console.log(event)
  console.log(context)

  // 获取 WX Context (微信调用上下文)，包括 OPENID、APPID、及 UNIONID（需满足 UNIONID 获取条件）
  const wxContext = await cloud.getWXContext()

  return {
    event,
    openid: wxContext.OPENID,
    appid: wxContext.APPID,
    unionid: wxContext.UNIONID,
  }
}

```

从而在小程序入口文件 `app.js` 中，利用通过云开发功能获取的openid，可以在数据库中对比曾经注册过的用户的openid，判断后台数据库中是否存在该用户的数据，有则初始化使用者设备上的显示信息，无则调用注册代码，新建用户信息并初始化任务列表，该设计过程与 `数据结构设计` 一节重复，可回看该节。

## 复选框功能实现

在两大主要模板 `任务列表`中，主要使用了复选框实现点击增加一次"使用"的功能。

> 实现效果

1. 点击后，使用次数+1
2. 若点击后总使用次数不满足设定的目标使用次数：选中显示暂停一段时间后消失
3. 若点击后总使用次数满足设定的目标使用次数：选中后任务移动到"已完成"折叠栏里

> 代码实现

前端页面：在"任务列表的每一项"的wxml模板`taskTemplate` 中的 `<view class="task-item-wrap"> `里，显示复选框，其中，用任务状态 `item.status.finished || item.status.checked` 决定复选框的显示状态：

1. 未完成：可选，选中时显示蓝点
2. 已完成：不可选，灰色

```html
<checkbox disabled="{{ item.status.finished || item.status.checked }}" class="item-checkbox {{ item.status.checked ? 'item-checkbox--checked' : '' }}" checked="{{ item.status.checked || item.status.finished }}" data-taskindex="{{ index }}" catch:tap="checkboxChange" />
```

使用 `catch:tap="checkboxChange"` 链接到后端buy.js中的处理代码 `checkboxChange` 函数，其中处理了：

1. 任务次数逻辑

2. 任务奖励逻辑

3. 增加经验

4. 处理'已完成'列表数量

   ```js
           var checkedNum = this.data.checkedNum
           if (item.status.finished) {
               checkedNum++
           }
   ```

5. 任务期限判断与处理

6. 增加收入记录

7. 修改后的数据渲染

   ```js
           this.setData({
               userData: user, 
               taskData: task,
               checkedNum: checkedNum,
               expiredNum: expiredNum
           })
   ```

8. 重点处理：未完成则取消复选框勾选

   ```js
           if (item.checkcount <= item.count || item.count === 0) {
               setTimeout(() => {
                   item.status.checked = false
                   task[taskindex] = item
                   this.setData({
                   taskData: task
                   })
                   // 修改对应Storage
                   wx.setStorageSync('taskData', this.data.taskData)
                   wx.setStorageSync('userData', this.data.userData)
               }, 700);
           }
   ```

## 悬浮按钮功能实现

### 移动功能

使用可移动的组件 `movable-area` 可简单获取按钮移动功能：

1. direction属性控制按钮只能上下移动
2. x、y控制按钮初始位置
3. bindtap：手指触摸后马上移开的后台触发事件

```html
    <!-- 添加任务：浮动 -->
    <movable-area style="height:82%; width:1rpx; " class="move-area">
        <movable-view direction="vertical" class="set-button" x="0" y="500" out-of-bounds="true" damping="20" bindtap="clickButton" inertia="true">+</movable-view>
    </movable-area>
```

### 弹框与数据提交

该按钮在两大模块，即 `任务列表`、`欲望商店`中均有使用以提交新增的剁手商品或预期购买的欲望商品，实现原理如下。 

在 `bindtap` 绑定的后台 `clickButton`函数中处理弹框显示与数据提交：

1. 用`data`，使用`key-value`存储数据
2. 使用 `this.setData` 更新js文件中的data数据

```js
    //点击+添加任务
    clickButton() {
        var data = {
            taskname: '',
            taskcount: '',
            indexType: 0,
            type: ['请选择物品类型', '日用品', '衣物饰品', '学习用品'],
            indexDiff: '',
            difficulty: ['请选择任务难度', '简单', '普通', '中等', '困难'],
            due: new Date().Format('yyyy-MM-dd'),
            checkcount: 0,
            lastwork: null,

            status: {
                finished: false,
                expired: false,
                today: false,
            }
        }

        this.setData({
            addTaskData: data,
            showModal: true,//显示弹框
        })
    },
```

其中，通过对变量 `showModal` 设置为true/false，实现点击"+"后出现弹框，触摸"保存"后弹框消失的功能，因为前段使用该变量作为 `if`  语句的判断条件，决定弹框出现与否：

```html
    <!-- 添加任务：弹框，点击+后showModal=true，显示 -->
    <view class="modalDlg" wx:if="{{showModal}}">
        <view class='close-mask' bindtap="close_mask">×</view>
        <view class="content">
            <input class='inputtext' type='text' placeholder='请输入物品名' value='{{addTaskData.taskname}}' bindinput="getTaskName"></input>
        ...
```

## 其余点击事件

其余点击事件的功能实现是简化版的悬浮按钮功能实现，均为wxml中使用空间的 `bind***` 属性，绑定后端同名.js文件中的处理函数，执行后使用 `this.setData`等手段实现对前端界面的重新渲染。

因此此处不再赘述。

## 页面切换

主要在触摸部件属性触发的绑定的.js文件中的函数使用 `wx.navigateTo` 函数实现页面的转换：

首次打开小程序，用户不存在时调用注册功能：

```js
        else {
          console.log('[数据库] [查询记录] 成功 云端没有该用户信息，建立新用户')
          wx.navigateTo({
            url: '../login/login',
          })
        }
```

主页中触摸转换到 `任务列表`/ `欲望商店` 模块：

```js
 goTask: function () {
    wx.navigateTo({
      url: 'buy/buy',
    })
  },
  goStore: function () {
    wx.navigateTo({
      url: 'desirestore/desirestore',
    })
  },
```

"我的"中转移到其他3个模块：

```js
    changePage: function(e) {
        var pagename = e.currentTarget.dataset.pagename
        if (pagename === '积分账单') {
            wx.navigateTo({
                url: './record/record'
            })
        } else if (pagename === '关于我们') {
            wx.navigateTo({
                url: './aboutus/aboutus'
            })
        } else if (pagename === '使用方法') {
            wx.navigateTo({
                url: './instruction/instruction',
            })
        }
    },
```



# 八、运行流程

以上部分具体介绍了该小程序的主要设计逻辑与方法，设计完成后，小程序的总体使用逻辑如下：

小程序执行入口文件为根目录下的app.js，小程序启动，便首先执行该文件内容，即判断用户是否存在，实现用户数据的同步、或新建用户信息。

总入口执行完后，按照app.json 中定义的 pages 的顺序逐一执行.js文件：

```json
  "pages": [
    "pages/index/index",
    "pages/index/buy/buy",
    "pages/index/desirestore/desirestore",
    "pages/login/login",
    "pages/me/me",
    "pages/me/record/record",
    "pages/me/aboutus/aboutus",
    "pages/me/instruction/instruction"
  ],
```

首行即为小程序进入后首先显示的主页，其余行均为代码目录中的某项。因此首先显示的为主页，随后即可按照用户的触摸，通过wxml的部件属性绑定的后端函数，调用/显示/处理不同的界面与功能。